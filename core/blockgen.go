package core

import (
	"errors"
	"math"
	"time"

	"go.uber.org/zap"
	exprand "golang.org/x/exp/rand"
	"gonum.org/v1/gonum/stat/distuv"
)

// Random messages are generated in a simulation
//   otherwise the simulation is quiet and unintersting
// Apart from the control messages generated by the protocol,
//   the data messages are typically new blocks generated by miners which we simulate here

var (
	NegBlockRateErr = errors.New("Cannot specify a negative block interval")
)

type OracleBlockGenerator struct {
	sched       *Scheduler
	genDist     Dist
	pubSelector Dist
	publishers  []BlockPublisher
	rng         exprand.Source
	logger      *zap.Logger
}

type BlockGenEvent struct {
	oracle *OracleBlockGenerator
}

type BlockPublisher interface {
	PublishNewBlock()
	ID() int64
}

// Assumes that
// - the block intervals follow an exponential distribution
// rate has a precision of milliseconds
// generates the initial block and schedules for generating further blocks
func NewBlockGenerator(
	sched *Scheduler,
	blockInterval time.Duration,
	rng exprand.Source,
	logger *zap.Logger,
) (*OracleBlockGenerator, error) {
	if blockInterval <= 0 {
		return nil, NegBlockRateErr
	}
	genDist := &distuv.Exponential{
		Rate: 1.0 / float64(blockInterval.Milliseconds()),
		Src:  rng,
	}
	oracle := &OracleBlockGenerator{
		sched:       sched,
		genDist:     genDist,
		pubSelector: nil,
		publishers:  []BlockPublisher{},
		logger:      logger,
		rng:         rng,
	}
	oracle.oracleNewBlock()
	return oracle, nil
}

func (oracle *OracleBlockGenerator) AddPublisher(publisher BlockPublisher) {
	oracle.publishers = append(oracle.publishers, publisher)
	oracle.pubSelector = &distuv.Uniform{
		Min: 0.0,
		Max: float64(len(oracle.publishers)),
		Src: oracle.rng,
	}
}

func (oracle *OracleBlockGenerator) oracleNewBlock() {
	nextBlockInterval := time.Duration(math.Round(oracle.genDist.Rand())) * time.Millisecond
	oracle.sched.Schedule(nextBlockInterval, &BlockGenEvent{
		oracle: oracle,
	})
}

func (oracle *OracleBlockGenerator) PublishNewBlock() {
	selectedID := int(math.Round(oracle.pubSelector.Rand()))
	if selectedID < 0 {
		selectedID = 0
	}
	if selectedID >= len(oracle.publishers) {
		selectedID = len(oracle.publishers) - 1
	}
	selectedPub := oracle.publishers[selectedID]

	oracle.logger.Debug(
		"Publishing a new block",
		zap.Time("CurTime", oracle.sched.CurTime),
		zap.Int64("nodeID", selectedPub.ID()),
	)
	selectedPub.PublishNewBlock()
	oracle.oracleNewBlock()
}

// Implements event interface to generate blocks separated by intervals derived from an exponential distribution
func (blockGenEvent *BlockGenEvent) Trigger() {
	blockGenEvent.oracle.PublishNewBlock()
}
