package core

import (
	"errors"
	"math"
	"testing"
	"time"

	"go.uber.org/zap"
	exprand "golang.org/x/exp/rand"
)

// Dummy node for simulating block generation
type BlockPubNode struct {
	counter int
	id      int
}

func (node *BlockPubNode) PublishNewBlock() {
	node.counter++
}

func (node *BlockPubNode) ID() int64 {
	return int64(node.id)
}

func TestNegRate(t *testing.T) {
	var err error

	nullLogger := zap.L()

	sched, _ := NewScheduler(time.Hour)

	_, err = NewBlockGenerator(sched, -1*time.Second, exprand.NewSource(48), nullLogger)
	if !errors.Is(err, NegBlockRateErr) {
		t.Error("Cannot support negative block rate!")
	}

	_, err = NewBlockGenerator(sched, 0, exprand.NewSource(48), nullLogger)
	if !errors.Is(err, NegBlockRateErr) {
		t.Error("Cannot support zero block rate!")
	}
}

func TestBlocksGenerated(t *testing.T) {
	nullLogger := zap.L()

	dur := 150_000
	sched, _ := NewScheduler(time.Duration(dur) * time.Second)
	blockInterval := 15
	rate := 1.0 / float64(blockInterval)
	oracle, err := NewBlockGenerator(sched, time.Duration(blockInterval)*time.Second, exprand.NewSource(48), nullLogger)
	if err != nil {
		t.Errorf("Unexpected error: %v", err)
	}

	for i := 0; i < 10; i++ {
		oracle.AddPublisher(&BlockPubNode{
			counter: 0,
			id:      i,
		})
	}

	sched.Run()

	tolerance := 1e2
	expectedTriggered := int64(rate * float64(dur))
	if math.Abs(float64(sched.NumTriggered-expectedTriggered)) > tolerance {
		t.Errorf("Number of blocks generated: %v", sched.NumTriggered)
	}
}

func TestSelector(t *testing.T) {
	nullLogger := zap.L()

	dur := 150_000
	sched, _ := NewScheduler(time.Duration(dur) * time.Second)
	blockInterval := 15
	rate := 1.0 / float64(blockInterval)
	oracle, _ := NewBlockGenerator(sched, time.Duration(blockInterval)*time.Second, exprand.NewSource(84), nullLogger)

	nodes := []*BlockPubNode{}
	numNodes := 10
	for i := 0; i < numNodes; i++ {
		node := &BlockPubNode{
			counter: 0,
			id:      i,
		}
		nodes = append(nodes, node)
		oracle.AddPublisher(node)
	}

	sched.Run()

	expectedPerNode := int64(rate*float64(dur)) / int64(numNodes)
	// ommitting the first and last node to reduce noise
	for i := 1; i < numNodes-1; i++ {
		tolerance := 1e2
		if math.Abs(float64(int64(nodes[i].counter)-expectedPerNode)) > tolerance {
			t.Errorf(
				"Number of blocks were generated by node with ID %v: %v",
				nodes[i].ID(),
				nodes[i].counter,
			)
		}
	}
}
